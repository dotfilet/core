#!/usr/bin/env zsh

# Logging

autoload -U colors
colors

color_format() (
  local string="${@}"
  local stack=(default)
  
  while [[ "${string}" =~ '{{([^}]+)}}' ]]; do
    echo -n "${string:0:($MBEGIN - 1)}"

    color="${match[1]}"
    if [[ "${color}" == "/" ]]; then
      current="${stack[-1]}"
      shift -p stack
      if [[ "${current}" == "dim" ]]; then
        echo -n "[22m"
      else
        color="${stack[-1]}"
      fi
    else
      stack+=("${color}")
    fi

    if [[ "${color}" == "dim" ]]; then
      echo -n "[2m"
    else
      echo -n "${fg[$color]}"
    fi

    string="${string:$MEND}"
  done
  echo -n "${string}"
)

log() (
  echo $(color_format "$@[0m") >&2
)

log_debug() (
  log "{{dim}}$@"
)

log_warn() (
  log "{{yellow}}@" 
)

log_error() (
  log "{{red}}$@" 
)

fail() (
  log_error "$@"
  return 1
)
# Script Environment

import() {
  local repository="${1}"

  if [[ "${repository}" =~ ^github: ]]; then
    import_git "https://github.com/${repository:7}"
  elif [[ -d "${repository}" ]]; then
    import_path "${repository}"
  else
    fail "Not able to resolve repository {{yellow}}${repository}{{/}} to import"
  fi
}

import_git() {
  local url="${1}"
  local relative_path="${url:8}" # assuming https://â€¦
  local cache_dir="${FILET_STATE_DIR}/repositories/${relative_path}"

  if [[ -d "${cache_dir}" ]]; then
    log "Updating ${cache_dir} with latest commit from ${url}"

    git -C "${cache_dir}" pull --depth 1 --rebase --quiet
  else
    log "Caching ${url} to ${cache_dir}â€¦"

    mkdir -p "${cache_dir:h}"
    git clone --depth 1 "${url}" "${cache_dir}"
  fi

  import_path "${cache_dir}"
}

import_path() {
  local repository_path="${1:A}"

  log_debug "import ${repository_path}"

  if [[ ! -d "${repository_path}" ]]; then
    fail "Unable to import unknown directory {{magenta}}${repository_path}{{/}} ({{magenta}}${repository_path}{{/}})"
  fi
  
  FILET_REPOSITORIES+=("${repository_path}")
}

use() {
  local module="${1}"
  local variable_name="${${module//[.\/-]/_}:u}"

  # Only use each module once.
  env_flag="FILET_MODULE_LOADED_${variable_name}"
  if (( ${(P)+env_flag} )); then return; fi
  eval "${env_flag}=yes"
  log_debug "use ${module}"

  module_path=$(resolve_module "${module}")
  eval "FILET_MODULE_ROOT_${variable_name}=${module_path:h}"

  evaluate_script "${module_path}"
}

resolve_module() (
  local module="${1}"

  if [[ "${module}" =~ ^".+/" ]]; then
    cd "${FILET_CURRENT_MODULE_ROOT}"
    local full_path="${module:A}"
    cd -

    if [[ -f "${full_path}"/module.filet ]]; then
      echo "${full_path}"/module.filet
      return 0
    elif [[ -f "${full_path}".filet ]]; then
      echo "${full_path}".filet
      return 0
    else
      log_error "The local module ${module} must exist at either:"
      log_error
      log_error "  ${full_path}/module.filet"
      log_error "  ${full_path}.filet"
      return 1
    fi
  fi

  for repository in "${FILET_REPOSITORIES[@]}"; do
    if [[ -f "${repository}"/"${module}"/module.filet ]]; then
      echo "${repository}"/"${module}"/module.filet
      return 0
    elif [[ -f "${repository}"/"${module}".filet ]]; then
      echo "${repository}"/"${module}".filet
      return 0
    fi
  done

  log_error "Unable to locate module {{yellow}}${module}{{/}} via search paths:"
  log_error
  for repository in "${FILET_REPOSITORIES[@]}"; do
    log_error "  ${repository}"
  done
  return 1
)

git_sync() (
  local destination="${1:A}"
  local url="${2}"

  log_debug "git_sync ${url} ${destination}"

  if [[ -d "${destination}"/.git ]]; then
    git -C "${destination}" pull --depth 1 --rebase --quiet
  else
    git clone --depth 1 "${url}" "${destination}"
  fi  
)

url_sync() (
  local destination="${1:A}"
  local url="${2}"

  log_debug "url_sync ${url} ${destination}"

  mkdir -p "$(dirname "${destination}")"
  curl --silent --location "${url}" --output "${destination}"
)

copy() (
  local destination="${1:A}"
  local source="${2}"

  if [[ "${source}" == "" ]]; then
    if [[ "${destination}" == "$HOME"/* ]]; then
      source="./${destination#"$HOME"/}"
    else
      fail "please provide a path to the file to copy (relative to the module)"
    fi
  fi

  cd "${FILET_CURRENT_MODULE_ROOT}"
  source="${source:A}"
  cd -

  log_debug "copy ${destination} <- ${source}"

  if [[ -d "${source}" ]]; then
    source="${source}"/
    destination="${destination}"/
  fi

  cp -rf "${source}" "${destination}"
)

evaluate_script() {
  local script="${1}"

  if [[ ! -f "${script}" ]]; then
    fail "Can't locate filet script {{magenta}}${script}{{/}} ({{magenta}}${script:A}{{/}})"
  fi
  
  if [[ ! -v FILET_ROOT_SCRIPT ]]; then
    FILET_ROOT_SCRIPT="${script:A}"
    FILET_ROOT_DIR="${script:A:h}"
    FILET_STATE_DIR="${FILET_ROOT_DIR}/.filet"
    FILET_REPOSITORIES=()
  fi

  local previous_module_root="${FILET_CURRENT_MODULE_ROOT}"
  FILET_CURRENT_MODULE_ROOT="${script:A:h}"

  source "${script}"

  FILET_CURRENT_MODULE_ROOT="${previous_module_root}"
}

# Command: apply

command_apply_help() (
  log "Usage: {{cyan}}filet{{/}} {{yellow}}apply{{/}} {{magenta}}file.filet{{/}}"
)

command_apply_main() (
  local root_script="${1}"
  if [[ "${root_script}" == "" ]]; then
    command_apply_help
    return 1
  fi

  cd "${root_script:h}"
  evaluate_script "${root_script}"
)
# Command: help

command_help_main() (
  local command="${1}"

  if [[ "${command}" == "" ]]; then
    default_help
  elif ! is_function "command_${command}_main"; then
    log_error "Unknown command: {{yellow}}${command}{{/}}"
    log
    default_help
  elif ! is_function "command_${command}_help"; then
    log_error "The {{yellow}}${command}{{/}} command failed to implement command_${command}_help"
    log
    default_help
  else
    "command_${command}_help"
  fi

  exit 1
)

default_help() (
  log "Usage: {{cyan}}filet{{/}} {{yellow}}command{{/}}"
)

# Entry Point

main() (
  log

  local positional=()
  local flags=()

  for argument in "${@}"; do
    if [[ "${argument}" =~ ^-+ ]]; then
      flags+=("${argument}")
    else
      positional+=("${argument}")
    fi
  done

  if (( $flags[(Ie)--help] )) || (( $flags[(Ie)-h] )) || ! is_function "command_${positional[1]}_main"; then
    if [[ "${positional[1]}" != "help" ]]; then
      positional=(help "${positional[@]}")
    fi
  fi
  
  (
    set -e
    "command_${positional[1]}_main" "${positional[@]:1}" "${flags[@]}"
  )
  local result=$?

  log

  return $result
)

is_function() (
  typeset -f "${1}" > /dev/null
)

main "$@"
